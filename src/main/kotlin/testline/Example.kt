/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package testline

// Input/output
import java.io.IOException
import java.nio.file.Paths
// Date and time
import java.time.LocalDate
import java.time.LocalTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeFormatterBuilder
// Timers functionality
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
// Tmux functionality
import java.util.function.Consumer

// jline-builtins
import org.jline.builtins.Commands
import org.jline.builtins.Completers
import org.jline.builtins.Completers.TreeCompleter
import org.jline.builtins.Options.HelpException
import org.jline.builtins.TTop
// jline-keymap
import org.jline.keymap.KeyMap
// jline-reader
import org.jline.reader.*
import org.jline.reader.impl.DefaultParser
import org.jline.reader.impl.DefaultParser.Bracket
import org.jline.reader.impl.LineReaderImpl
import org.jline.reader.impl.completer.ArgumentCompleter
import org.jline.reader.impl.completer.StringsCompleter
// jline-terminal
import org.jline.terminal.Cursor
import org.jline.terminal.MouseEvent
import org.jline.terminal.Terminal
import org.jline.terminal.TerminalBuilder
// jline-utils
import org.jline.utils.AttributedString
import org.jline.utils.AttributedStringBuilder
import org.jline.utils.AttributedStyle
import org.jline.utils.InfoCmp.Capability
import org.jline.utils.Status

import java.time.temporal.ChronoField.HOUR_OF_DAY
import java.time.temporal.ChronoField.MINUTE_OF_HOUR
import org.jline.builtins.Completers.TreeCompleter.node

//typealias Consumer<T> = (T) -> Unit

class Example {
  companion object {
    private val usage = listOf(
      "Usage: java ${Example::class.java.getName()} [cases... [trigger mask]]",
      "  Terminal:",
      "    -system           terminalBuilder.system(false)",
      "    +system           terminalBuilder.system(true)",
      "  Completers:",
      "    argument          an argument completer",
      "    files             a completor that completes file names",
      "    none              no completers",
      "    param             a parameter completer using Java functional interface",
      "    regexp            a regex completer",
      "    simple            a string completer that completes \"foo\", \"bar\" and \"baz\"",
      "    tree              a tree completer",
      "  Multiline:",
      "    brackets          EOF on unclosed bracket",
      "    quotes            EOF on unclosed quotes",
      "  Mouse:",
      "    mouse             enable mouse",
      "    mousetrack        enable tracking mouse",
      "  Miscellaneous:",
      "    color             colored left and right prompts",
      "    status            multi-thread test of JLine status line",
      "    timer             widget 'Hello World'",
      "    <trigger> <mask>  password mask",
      "  Example:",
      "    java ${Example::class.java.getName()} simple su '*'"
    )

    private val help = listOf(
      "List of available commands:",
      "   Builtin:",
      "     complete          UNAILABLE",
      "     history           list history of commands",
      "     keymap            manipulate keymaps",
      "     less              file pager",
      "     nano              nano editor",
      "     setopt            set options",
      "     tmux              UNAVAILABLE",
      "     ttop              display and update sorted information about threads",
      "     unsetopt          unsetoptions",
      "     widget            UNAVAILABLE",
      "   Example:",
      "     cls               clear screen",
      "     help              list available commands",
      "     exit              exit from this app",
      "     set               set lineReadder variable",
      "     sleep             sleep 3 seconds",
      "     testkey           display key events",
      "     tput              set terminal capability",
      "   Additional help:",
      "     <command> --help"
    )

    public fun usage() {
      for (item in usage) {
        println(item)
      }
    }

    public fun help() {
      for (item in help) {
        println(item)
      }
    }

    @JvmStatic
    public fun main(args: Array<String>) {
      try {
        var prompt = ">> "
        var rightPrompt = ""
        var mask = '\u0000'
        var trigger: String? = null
        var color = false
        var timer = false

        val builder: TerminalBuilder = TerminalBuilder.builder()

        if (args.isNullOrEmpty()) {
          usage()

          return
        }

        var mouse = 0

        var completer: Completer? = null
        var parser: Parser? = null
        val callbacks = mutableListOf<(LineReader) -> Unit>()

        for (index in 0 .. args.size) {
          when (args[index]) {
            "timer" -> { timer = true }
            "-system" -> { builder.system(false).streams(System.`in`, System.`out`) }
            "+system" -> { builder.system(true) }
            "none" -> { }
            "files" -> { completer = Completers.FileNameCompleter() }
            "simple" -> { completer = StringsCompleter("foo", "bar", "baz") }
            "quotes" -> {
              val p: DefaultParser = DefaultParser()
              p.setEofOnUnclosedQuote(true)
              parser = p
            }
            "brackets" -> {
              prompt = "|}>- "
              val px: DefaultParser = DefaultParser()
              px.setEofOnUnclosedBracket(Bracket.CURLY, Bracket.ROUND, Bracket.SQUARE)
              parser = px
            }
            "status" -> {
              completer = StringsCompleter("foo", "bar", "baz")
              callbacks.add() { reader: LineReader ->
                (Thread() {
                  var counter = 0
                  while (true) {
                    try {
                      val status: Status = Status.getStatus(reader.getTerminal())
                      counter ++
                      status.update(listOf(AttributedStringBuilder().append("counter: $counter").toAttributedString()))
                      (reader as LineReaderImpl).redisplay()
                      Thread.sleep(1000)
                    } catch (e: InterruptedException) {
                      e.printStackTrace()
                    }
                  }
                }).start()
              }
            }
            "argument" -> {
              completer = ArgumentCompleter(
                StringsCompleter("foo11", "foo12", "foo13"),
                StringsCompleter("foo21", "foo22", "foo23"),
                object: Completer {
                  override fun complete(reader: LineReader?, line: ParsedLine?, candidates: MutableList<Candidate?>) {
                    candidates.add(Candidate("", "", null, "frequency in MHz", null, null, false))
                  }
                }
              )
            }
            "param" -> {
              completer = Completer { reader, line, candidates ->
                if (line.wordIndex() == 0) {
                  candidates.add(Candidate("Command1"))
                } else if (line.words()[0] == "Command1") {
                  if (line.words()[line.wordIndex() - 1] == "Option1") {
                    candidates.add(Candidate("Param1"))
                    candidates.add(Candidate("Param2"))
                  } else {
                    if (line.wordIndex() == 1) {
                      candidates.add(Candidate("Option1"))
                    }
                    if (!line.words().contains("Option2")) {
                      candidates.add(Candidate("Option2"))
                    }
                    if (!line.words().contains("Option3")) {
                      candidates.add(Candidate("Option3"))
                    }
                  }
                }
              }
            }
            "tree" -> {
              completer = TreeCompleter(
                node("Command1",
                  node("Option1",
                    node("Param1", "Param2")
                  ),
                  node("Option2"),
                  node("Option3")
                )
              )
            }
            "regexp" -> {
              val comp = HashMap<String, Completer>()
              comp.put("C1", StringsCompleter("cmd1"))
              comp.put("C11", StringsCompleter("--opt11", "--opt12"))
              comp.put("C12", StringsCompleter("arg11", "arg12", "arg13"))
              comp.put("C2", StringsCompleter("cmd2"))
              comp.put("C21", StringsCompleter("--opt21", "--opt22"))
              comp.put("C22", StringsCompleter("arg21", "arg22", "arg23"))
              completer = Completers.RegexCompleter("C1 C11* C12+ | C2 C21* C22+", comp::get)
            }
            "color" -> {
              color = true
              prompt = AttributedStringBuilder()
                .style(AttributedStyle.DEFAULT.background(AttributedStyle.GREEN))
                .append("foo")
                .style(AttributedStyle.DEFAULT)
                .append("@bar")
                .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.GREEN))
                .append("\nbaz")
                .style(AttributedStyle.DEFAULT)
                .append("> ").toAnsi()
              rightPrompt = AttributedStringBuilder()
                .style(AttributedStyle.DEFAULT.background(AttributedStyle.RED))
                .append(LocalDate.now().format(DateTimeFormatter.ISO_DATE))
                .append("\n")
                .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.RED or AttributedStyle.BRIGHT))
                .append(LocalTime.now().format(DateTimeFormatterBuilder()
                  .appendValue(HOUR_OF_DAY, 2)
                  .appendLiteral(':')
                  .appendValue(MINUTE_OF_HOUR, 2)
                  .toFormatter()
                )).toAnsi()
              completer = StringsCompleter("\u001B[1mfoo\u001B[0m", "bar", "\u001B[32mbaz\u001B[0m", "foobar")
            }
            "mouse" -> {
              mouse = 1
            }
            else -> {
              if (index == 0) {
                usage()
              } else if (args.size == index + 2) {
                mask = args[index + 1][0]
                trigger = args[index]
                //index = args.size
              } else {
                println("Bad test case: ${args[index]}")
              }
            }
          }
        }

        val terminal: Terminal = builder.build()
        println("${terminal.getName()}: ${terminal.getType()}")
        println("\nhelp: list available commands")

        val reader: LineReader = LineReaderBuilder.builder()
          .terminal(terminal)
          .completer(completer)
          .parser(parser)
          .variable(LineReader.SECONDARY_PROMPT_PATTERN, "%M%P > ")
          .build()

        if (timer) {
          Executors.newScheduledThreadPool(1)
            .scheduleAtFixedRate({
              reader.callWidget(LineReader.CLEAR)
              reader.getTerminal().writer().println("Command line reinvented!")
              reader.callWidget(LineReader.REDRAW_LINE)
              reader.callWidget(LineReader.REDISPLAY)
              reader.getTerminal().writer().flush()
            }, 1, 1, TimeUnit.SECONDS)
        }

        if (mouse != 0) {
          reader.setOpt(LineReader.Option.MOUSE)
          if (mouse == 2) {
            reader.getWidgets().put(LineReader.CALLBACK_INIT, Widget {
              terminal.trackMouse(Terminal.MouseTracking.`Any`)
              true // returning true
            })
            reader.getWidgets().put(LineReader.MOUSE, Widget {
              val event: MouseEvent = reader.readMouseEvent()
              val tsb: StringBuilder = StringBuilder()
              val cursor: Cursor = terminal.getCursorPosition() { c ->
                tsb.append(c.toChar())
              }

              reader.runMacro(tsb.toString())
              val msg = "        ${event.toString()}"
              val w: Int = terminal.getWidth()

              terminal.puts(Capability.cursor_address, 0, Math.max(0, w - msg.length))
              terminal.writer().append(msg)
              terminal.puts(Capability.cursor_address, cursor.getY(), cursor.getX())
              terminal.flush()
              true // returning true
            })
          }
        }

        callbacks.forEach() { reader } // TODO: fix it

        while (true) {
          var line: String? = null

          try {
            line = reader.readLine(prompt, rightPrompt, null as MaskingCallback, null)
          } catch (e: UserInterruptException) {
            // Ignore here
          } catch (e: EndOfFileException) {
            return
          }

          if (line == null) {
            continue
          }

          line = line.trim()

          if (color) {
            terminal.writer().println(
              AttributedString.fromAnsi("\u001B[0m\"$line\"")
                .toAnsi(terminal)
            )
          } else {
            terminal.writer().println("======>\"$line\"")
          }

          terminal.flush()

          // Mask the next line is the special word is in input
          if ((trigger != null) && (line.compareTo(trigger) == 0)) {
            line = reader.readLine("password> $mask")
          }

          // Exit if "quit" or "exit" is in input
          if (line.equals("quit", true) || line.equals("exit", true)) {
            break
          }

          val pl: ParsedLine = reader.getParser().parse(line, 0)
          val argv: Array<String> = pl.words().subList(1, pl.words().size).toTypedArray()
          try {
            if ("set".equals(pl.word())) {
              if (pl.words().size == 3) {
                reader.setVariable(pl.words().get(1), pl.words().get(2))
              } else {
                terminal.writer().println("Usage: set <name> <value>")
              }
            } else if("tput".equals(pl.word())) {
              if (pl.words().size == 2) {
                val vcap: Capability? = Capability.byName(pl.words()[1])
                if (vcap != null) {
                  terminal.puts(vcap)
                } else {
                  terminal.writer().println("Unknown capability")
                }
              } else {
                terminal.writer().println("Usage: tput <capability>")
              }
            } else if ("testKey".equals(pl.word())) {
              terminal.writer().write("Input the key event (Enter to complete): ")
              terminal.writer().flush()
              val sb: StringBuilder = StringBuilder()
              while (true) {
                val c: Int = (reader as LineReaderImpl).readCharacter()
                if (c == 10 || c == 13) {
                  break
                }
                sb.append(String(Character.toChars(c)))
              }
              terminal.writer().println(KeyMap.display(sb.toString()))
              terminal.writer().flush()
            } else if ("cls".equals(pl.word())) {
              terminal.puts(Capability.clear_screen)
              terminal.flush()
            } else if ("sleep".equals(pl.word())) {
              Thread.sleep(3000) // hardcoded
            } // Builtin commands to test HelpPrinter class
            else if ("tmux".equals(pl.word())) {
              Commands.tmux(terminal, System.`out`, System.`err`,
                null, // Supplier<Object> getter
                null, // Consumer<Object> setter
                null, // Consumer<Terminal> runner
                argv
              )
            } else if ("nano".equals(pl.word())) {
              Commands.nano(terminal, System.`out`, System.`err`,
                Paths.`get`(""),
                argv
              )
            } else if ("history".equals(pl.word())) {
            } else if ("complete".equals(pl.word())) {
              Commands.complete(reader, System.`out`, System.`err`,
                null, // Map<String, List<CompletionData>> completions
                argv
              )
            } else if ("widget".equals(pl.word())) {
              Commands.widget(reader, System.`out`, System.`err`,
                null, // Function<String, Widget> widgetCreator
                argv
              )
            } else if ("keymap".equals(pl.word())) {
              Commands.keymap(reader, System.`out`, System.`err`, argv)
            } else if ("setopt".equals(pl.word())) {
              Commands.setopt(reader, System.`out`, System.`err`, argv)
            } else if ("unsetopt".equals(pl.word())) {
              Commands.unsetopt(reader, System.`out`, System.`err`, argv)
            } else if ("ttop".equals(pl.word())) {
              TTop.ttop(terminal, System.`out`, System.`err`, argv)
            } else if ("help".equals(pl.word())) {
              help()
            }
          } catch(e: HelpException) {
            HelpException.highlight(e.message, HelpException.defaultStyle()).print(terminal)
          } catch(e: IllegalArgumentException) {
            println(e.message)
          }
        }
      } catch (t: Throwable) {
        t.printStackTrace()
      }
    }
  }
}

fun main(args: Array<String>) {
  Example.main(args)
}

// vim: se et ts=2 sw=2 number:
